{
  "name": "promises",
  "description": "A flexible and generic promise implementation for Javascript libraries",
  "author": {
    "name": "Jacob Wright",
    "email": "jacwright@gmail.com"
  },
  "keywords": [
    "commonjs",
    "promises/a",
    "server",
    "client",
    "browser"
  ],
  "version": "0.2.5",
  "main": "lib/promises",
  "maintainers": [
    {
      "name": "Jacob Wright",
      "email": "jacwright@gmail.com",
      "url": "http://jacwright.com"
    }
  ],
  "contributors": [
    {
      "name": "Jacob Wright",
      "email": "jacwright@gmail.com",
      "url": "http://jacwright.com"
    }
  ],
  "homepage": "https://github.com/jacwright/promises",
  "repository": {
    "type": "git",
    "url": "git://github.com/jacwright/promises.git"
  },
  "readme": "JavaScript Promises\n===================\n\nPromises is a JavaScript library and [node.js](http://nodejs.org/) module to allow easier handling of asynchronous flows. It is written in CoffeeScript but is easily used in any JavaScript applications.\n\nIntro\n-----\nPromises (or deferreds) allow a more concise and easily readable way to deal asynchronous data. They are often desirable over callbacks. jQuery now supports [Deferreds](http://api.jquery.com/category/deferred-object/) for their Ajax methods, though they may be used outside of that. This library was created and has been in used before jQuery implemented their Deferred, and it could be improved with some of the ideas from jQuery.\n\n\nGetting Started\n---------------\n\nFor Node.js run `npm install promises`. For browser usage download promises.js and include it in your page.\n\nYou may wrap node.js libraries that follow the callback standards, i.e. the callback is the last parameter and follows the signature function(err, result).\n\n```\nvar promises = require('promises');\nvar fs = require('fs');\nvar writeFile = promises.wrap(fs.writeFile);\n\nwriteFile('test.txt', 'This is my text').then(function() {\n    // do what needs to be done\n}, function(err) {\n    // handle the error\n});\n```\n\n\n\n\nAdvanced Features\n-----------------\n\nTo pass data along you may return a new value from your resolve handler.\n\n```\nfunction addTwo(num) {\n    return num+2;\n}\n\nasyncAction().then(addTwo).then(alert); // will alert out 12 if asyncAction gives us 10\n```\n\nYou may pass `null` if you don't care to handle a result, but for `then()` there are also shortcut methods, e.g.\n```\nasyncAction().then(null, handleError);\nasyncAction().rejected(handleError); // this is the same as previous\n```\n\nUsing `then()` or any of its shortcuts (`resolved()`/`done()`, `rejected()`, `always()`, `progress()`, and `canceled()`)\nwill return a new promise which is resolved (or rejected) with value of the method passed to it.\n\nIn some cases you will want to flip from resolved or rejected to the other. For example, if you recover from an error\nyou can then handle the next promise as resolved. To do this, you will use the `promises.resolve()` or\n`promises.reject()` methods.\n\nExample:\n\n```\nfunction ifServiceOffLineUseCache(err) {\n    if (err.message === 'dbOffline') {\n        return promises.resolve(cache.load());\n    } else {\n        return err;\n    }\n}\n\ndb.load().rejected(ifOfflineUseCache).then(function(data) {\n    // if the database was offline we can recover by using our cache\n}, function(err) {\n    // if it was another error we can handle it as usual\n})\n```\n",
  "readmeFilename": "readme.md",
  "bugs": {
    "url": "https://github.com/jacwright/promises/issues"
  },
  "_id": "promises@0.2.5",
  "dist": {
    "shasum": "4cb20dcc6e212f0070bb5909e18f7584125e5d9f"
  },
  "_from": "promises@",
  "_resolved": "https://registry.npmjs.org/promises/-/promises-0.2.5.tgz"
}
